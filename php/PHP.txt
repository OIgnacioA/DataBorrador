
------------------------PHP:
direcciones: 

---------------------------------------------***self:static: parent::



https://www.youtube.com/watch?v=L9jLxuLAAIY&ab_channel=DaniKrossing
https://www.geeksforgeeks.org/new-self-vs-new-static-in-php/
https://es.acervolima.com/diferencia-entre-self-bar-y-static-bar-en-php/


   -.-.-
ejer4.php
<?php
class Person {

  private $name;
  private $eyeColor;
  private $age;

  public static $drinkingAge = 21; 

  public static function setDrinkingAge($newDR){
    self::$drinkingAge = $newDR; 
  }

}

?>
   -.-.-
<?php
  
  include 'ejer4.php';


 echo Person::$drinkingAge;
 Person::setDrinkingAge(12);
 echo Person::$drinkingAge;
 
?>

>>>21 12


---------------------------------° "self" 


Es la forma en que se refiere a la clase en caso de estar usandose un static, (que funciona como en java). es el equivalente    a "this->".  Es una palabra clave de PHP que representa la clase actual y se utiliza para acceder a variables de clase estáticas o variables estáticas porque estos miembros pertenecen a una clase en lugar del objeto de esa clase.

<?php

class demo {
  
    public static $bar = 10;
  
    public static function func() {
        echo self::$bar . "\n";
    }
}


class Child extends demo {
    public static $bar = 20;
  
}
  

demo::func();
Child::func();

?> 

>>10
>>10


Self SOLO se refiere a la versión en tiempo de compilación de $bar o, en términos más simples, se refiere a la VERSION DE LA CLASE EN QUE RESIDE.llama a las variables/funciones , de la cclase donde reside. 


-------------------------------------°STATIC: 

la palabra clave 'static' cubre la limitación contenida por la palabra clave 'self' al hacer cumplir el concepto de enlace estático tardío. 
En este escenario, static le pide al compilador que imprima la versión de la función para la clase que la solicitó.




<?php
   
// Declaring parent class
class demo {
   
    public static $bar = 10;
   
    public static function func() {
                   
        // Static in place of self
        echo static::$bar."\n";
    }
}
   
// Declaring child class
class Child extends demo {
    public static $bar = 20;
}
   
// Calling for demo's version of func()
demo::func();
   
// Calling for child's version of func()
Child::func();
   
?> 

>>10
>>20    :)

--------------------------------------°PARENT


Es posible que se encuentre escribiendo código que hace referencia a variables y funciones de las clases base. Esto es particularmente cierto si su clase derivada es una refinación o especialización del código en su clase base.

En lugar de usar el nombre literal de la clase base en su código, debería usar el nombre especial parent, el cual hace referencia al nombre de su clase base tal y como se entrega en la declaración extends de su clase. Al hacer esto, evita usar el nombre de su clase base en más de un lugar. Llegado el caso de que su árbol de jerarquía cambie durante la implementación, el cambio se puede efectuar con facilidad SIMPLEMENTE MODIFICANDO LA DECLARACION EXTENDS DE SU CLASE.

<?php
class A {
    function ejemplo() {
        echo "Soy A::ejemplo() y ofrezco funcionalidad básica.<br />\n";
    }
}

class B extends A {
    function ejemplo() {
        echo "Soy B::ejemplo() y ofrezco funcionalidad adicional.<br />\n";

        parent::ejemplo();
    }
}

$b = new B;

// Esto hace la llamada a B::ejemplo(), la cual llama a su vez a A::ejemplo().
$b->ejemplo();
?>



--------------------------Variables: Protected-public-private. alberto masutti 


tipos : 


°---------public :

hace que la variable/función se pueda acceder desde cualquier lugar, como por ejemplo otras clases y otras instancias de esa misma clase.


°----------private: 

hace que la variable/función solamente se pueda utilizar desde la misma clase que las define.


°---------protected:

 hace que la variable/función se puede acceder desde la clase que las define y también desde cualquier otra clase que herede de ella.
En otras palabras: private = solo tú, protected = tú y tus descendientes, public = cualquiera.



Los métodos PRIVATE o PROTECTED no pueden ser accedidas fuera de la clase. private solo puede ser accedida dentro de la propia clase y protected dentro de la clase y clases heredadas, pero NO POR FUERA DEL CUERPO DE LA CLASE (y en una funcion aparentemente...¬¬).


Puedes crear un método público que acceda al método protected, o private, para que retorne (get) o introduzca (set) los valores que necesitas a la clase.

De forma predeterminada, las variables siempre se asignan por valor. Esto significa que cuando se asigna una expresión a una variable, el valor completo de la expresión original se copia en la variable de destino.
Para asignar por referencia, simplemente se antepone un signo ampersand (&) al comienzo de la variable cuyo valor se está asignando (la variable fuente). Por ejemplo, el siguiente segmento de código produce la salida 'Mi nombre es Bob' dos veces:

<?php
  $foo = 'Bob';                // Asigna el valor 'Bob' a $foo
  $bar = &$foo;                // Referenciar $foo vía $bar.
  $bar = "Mi nombre es $bar";  // Modifica $bar...
  echo $bar;
  echo $foo;                   // $foo también se modifica.
?>


En PHP, las variables globales deben ser declaradas globales dentro de la función si van a ser utilizadas dentro de dicha función.


<?php
	$a = 1;
	$b = 2;

	function Suma()
	{
 	   global $a, $b;

  	  $b = $a + $b;
	}

	Suma();
	echo $b;
?>


>>>>3.

_____**** Funciones: 


 Las funciones variables son las primeras en generar un dolor de cabeza en php: un ejemplo : tenemos una funcion: 

<?php

function buenasTardes() {

 retur "Hey!! buenos dias!!!";

}


$horario = "bunasTardes";

echo $horario(); 

?>

la variable $horario recibe el valor de la funcion "buenasTardes", ( se estaría convirtiendo en un funcion) ya que al hacer echo el valor que devuelve es e return de la funcion que el fue asignada. "Hey!! buenos dias!!!", y no "buenasTardes" como se podría esperar. 

y se pone peor: 


si formamos el nombre d ela funcion concatenando llamariamos a su return...: 


<?php

function buenasTardes() {

 retur "Hey!! buenos dias!!!";

}


$horario = "Tardes";

$unaFuncion= "buenas".$horario; 

echo $unaFuncion(); 


?>

>>>"Hey!! buenos dias!!!"


---> dentro de una variable se uede concatenar una variable ($horario) mas un valor local ("buenas") esto le daría a la funcion "$unaFuncion" el valor "buenasTardes", lo que sería como un llamado al echo de esa funcion. ....lpm...



 

-----**constantes: 

datos que no podrán ser modificdos. Se llaman sin el $

declaracion : define ('nombre', 'victor Robles'):

echo nombre


>>>vistor roble

----------------------*** variables superglobales: 

variables de servidor: 

echo $_SERVER ['SERVER_ADDR'];    //_ server es una array btw, y addr es para sacar la direcion ip del servidor. 


$_SERVER es un array que contiene información, tales como cabeceras, rutas y ubicaciones de script. Las entradas de este array son creadas por el servidor web. No hay garantía que cada servidor web proporcione alguna de estas entradas, existen servidores que pueden omitir algunas o proporcionar otras no recogidas aquí. Un gran número de estas variables se encuentran recogidas en » especificación CGI 1.1, así que al menos debe esperar encontrar estas entradas.


Server se utiliza como una variable global que hace pedidos específicos de los datos de la web o navegador en la que se esté trabajando

$servidor = [
		"Host servidor "  => $_SERVER["SERVER_NAME"],
		"eNCABEZADO Host  "  => $_SERVER["HTTP_HOST"],
		"Software servidor "  => $_SERVER["DOCUMENT_ROOT"],
		"Pagina Actual  "  => $_SERVER["PHP_SELF"],
		"Ruta absoluta "  => $_SERVER["SCRIPT_FILENAME"],
	]


--------------var_dump(); 

proporciona información sobre el tamaño y tipo de datos de la variable y, en el caso de arrays y objetos, de los elementos que la componen. 


--------------------------print_r 


no da información sobre el tamaño de la variable ni sobre el tipo de datos.


---------------------------------------------***  Instance of 


instanceof se utiliza para determinar si una variable de PHP es un objeto instanciado de una cierta clase:


<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>


>>>>bool(true)
>>>>bool(false)


-----------------------------------------------***callable


la callable keyword clave se usa para forzar que un argumento de función sea una referencia a una función.

<?php
function printFormatted(callable $format, $str) {
  echo $format($str);
  echo "<br>";
}

function exclaim($str) { return $str . "!"; }
printFormatted("exclaim", "Hello World");
?>


--------------------------------------------------------------------***declare: 


When PHP is executing your script, the execution can be seen as a lot of statements being executed. Most statements cause a Tick, though not necessarily all statements do so.
his block would normally cause 5 ticks, as you are executing 5 statements:
$a = 1;
$B = 2;
$a = 3;
$B = 4;
$a = 5;

And this block would normally cause 5 ticks, and one more tick as the end of the while loop also is counted as a statement/tick:

while ($i < 5)
    $a++;


With the help of declare(ticks=N) and register_tick_function(), you can now execute code in between the statements/ticks. The register_tick_function specifies which function should be called when a tick event occurs. And the declare sets how many tick should pass, before a tick event occurs.

With declare(ticks=1) and register_tick_function('someFunction'); you will call someFunction() code in between every statement/tick.

If you use declare(ticks=3), then someFunction() will be executed on every third statement/tick.

Example:


function handler(){
    echo "x";
}
register_tick_function("handler");
$i = 0;
declare(ticks = 4) {
    while ($i < 9)
        echo ++$i;
}


This script will output: 1234x5678x9 It's that simple.


-------------------------------------------------------------------------------------
- concatenacion con ' . ' : "esto es un ejemplo" . $variable; 

-para imrimir por pantalla se usa "echo" o "print": echo "esto e sun ejemplo" . $variable; 
echo permite separar variables por comas. 

-include  (nombreDEfuncion.php); incluye una funcion dentro del código que esté en otra parte. 

-require funciona igual, solo q interrumpe el flujo de ejecucion si har error.

-el ambito local de las variables se comportadiferente a otros lenguajes por causa de la existencia de estos dos llamados. ejemplo : 

<?php 
$nombre="Juan";

funcion dameNombre() {

$nombre= "María";

}

dameNombre();

echo $nombre; 

?>

>>>> Juan. 


sisis, daría juan, aunque en otro lenguaje debería dar MAria. PHP se asegura si que variables externas que sobreescriban no lo hagan con variables locales en llamados de este tipo (require-include) Incluso no se puede acceder desde dentro de una funcion a lo que hay fuera, de locales a lo que hay fuera. se debe convertir la varible interna en global : 

funcion dameNombre() {

global $nombre(); 

}

ahora sabe que tiene que ir a una variable global que fue declaradafuera de la funcion. 

Las variables estáticas: se agrega static delante de la variable, para que, por ejemplo, al llamar a una funcion una variable que tuviera un contador, esta incremente en cada caso que se la llame. 

----------------------------

comprobar ue se ha pulsado un boton : isset($_POST["enviado"]) 

$usuario=$POST["nombre_usuario"]   (esto corresponde al envio en metodo post de un formulario dnd el cuadro de ingreso de texto ((<input type="text" ))tiene un name="nombre_usario". 

-----------------------------

las CONSTANTES van con $ con mayusculas, es de ambito global, con valores escalares, (divisibles) y se definene en la funcion define() si o si. 

defin("AUTOR", "Juan") el primer argumento es el nombre, el segundo el valor, y puede haber un tercero que es un bool, que es para saber si es o no sensible a las mayusculas. (por si no usaron mayuscolas en el valor de la constante tal como es el convenio hacerlo)

Un ejemplo de una constante predefinida que s epuede encontrar en la pagina: https://www.php.net/manual/es/language.constants.predefined.php sería : 

echo "la linea de esta intruccion es : " . _LINE_; 

al venir con el lenguaje de forma predefinida nonecesitamos usa el define (). 

------------------------------ action =  

<form name = "form1"  method="post" action="calculadora.php">  action marca a que archvo php esta direccionado el form. 


--------------------------------


en el envio de parametros por valor o referencia en php sucede que , por ejemplo: 


function incrementa(&$valor1) {

$valor1++;
return $valor1;

}


$numero=5;

echo incrementa ($numero) . "<br>"

echo &numero; 

antes de agregar el &, el resultado hubiera sido un 5 en la primer linea, y un 6 en la segunda, pero ahora  el argumento de la funcion lo recivia por referencia, y no por valor como antes, donde el numero quedaba encapsulado dentro d ela funcion, si conocer ningun valor fuera. El & genera un vinculo, una referencia, con lo que hay fuera de la funcion. , asi que ahora al incrementar dentro d ela funcion, tambien se incrementa numero, esta vez se imprimirá dos veces un 6, el primero se refiere a la funcion, y el segundo a lo que se ha incrementado dentro de la funcion. REFERENCIA es un VINCULO, que afecta a esa variable en todas sus apariciones.



----------------------------------Calsses : (var , $this, ->, function() como metodo, contrusctor y herencia. 

declaracion: 


************

class Coche {

var $rueda;
var $motor; 

    function Coche() {

	ESTE ES EL METODO CONSTRUCTOR DE LA CLASE. 
	(SE LLAMA IGUAL A LA CLASE)     


        $this-> rueda = 4; 
    }


    function girar () {
      echo "estoy girando";
   }

}

$renault = new Coche(); 


************* Var


se usa Var para las propiedades. es el equivalente a Public, y puede pornerse como no. 


************* $this->

Los metodos y las funciones son sinonimos siempre que la funcion este dentro de la clase. al objeto que se este creando en cad amomento, por ejemplo no s elo usa en el caso de uq esea una variable d etipo static, ya que esas siempre pertenecen a la clase padre. 

--- $this-> rueda = 4;  [se usa el '->' para referenciar a la variable de clase, y el '$this' para referenciar a la clase dnd se está trabajando.  ]

Si se busca hacer una llamada a un método en una de las instancias de la case :


$renault->girar();  para un método
echo $renault->rueda; para un atributo. 


************** function


se puede cambiar el valor de una variable  con una funcion, por ejemplo : 


function cambia_color ($color_nuevo) {

$this->color=$color_coche;

echo "el color de este coche es:" . $this->color; 
		
}


$renault->cambia_color("rojo"); 


*************** Herencia: 


sintaxis : 

class Camion *extends* Coche {

}


-----------------------------------------*** Parent : 



la instruccion Parent hace un llamado a una funcion de la clase padre, de la cual hereda la clase actual, y la ejecuta, para luego ejecutar el resto de comandos que se hallen dentro de la funcion donde fue llamada en la clase hijo. 

function arranca () {

   parent::arrancar()

     //otras intrucciones//

}

en este caso primero llamo a la funcion arrancar() que está en la clase super, padre, y luego dio lugar a otras intrucciones dentro de la funcion arranca(). 


-------------------------------------  *** private:
 

se puede agregar private a var $ruedas = 4;

y con eso se encapsula. 

para acceder se usan metodos Getter y setter. en este caso se llamaría al objeto que posee la porpiedad, y a su metodo geter:

	 echo " el auto 1 tiene " .$auto1 ->get_ruedas() . "ruedas <br>";


*************** protected:
 

los metodos getter y setter acceden a la variables d ela clase donde se hayan, por caso de sucederse uan herencia de esta clase, el objeto que herede los metodos no podrá acceder a sus propias variables utilizando lso getter y setter heredados. El modificador ***protected*** permite que las variables que se heredan puedan ser accedidas tambien desde otras clases herederas con métodos settet y getter heredados de igual modo. 


**************** static. -- self::

en el caso de PHP se usa el operado self para hacer referencia a una variable de tipo estatica, a diferencia de $this-> que solo hace referencia a aun campo de clase  de la clase donde se encuentra. el operador Self:: hace *referencia* a un campo estatico. dnd la -> se reempleza por el ::


si se desea restar diferentes variables de clase , o sumar, o lo que sea, se debe recordar si llevan &this, o self:: conforme si son de la propia clase o de la clase d ela que se está heredando y que alli sea static. :

 function precio_final () {

   $valor_final= $this->precio_base - self::$ayuda;

   return $valor final;


   }

En este ejemplo 1) '$valor final' esta declarado dentro del propio método, por eso no lleva '$this->',2)precio base si lleva '$this->' porque pertenece a la clase donde se está trabajando, y 3) $ayuda es una variable de clase heredada de tipo static, por lo que en vez de '$this->' lleva 'self::'.

Para llamar a un campo Static se debe usar la clase como en todo lenguaje. solo que en vez de un punto, se usan  los dos dos puntos ::   

compra_veiculo::$ayuda=1000 

en otros lenguajes se veria asi : 

compra_veiculo.ayuda; 

(importante:'$ayuda' no estaría en private en este caso, por eso no se esta usando un setter. )
una vez declaradas como private se debe acceder a ellas con un metodo, igualmente statatico. 

las variables estaticas se pueden trabajar desde funciones estaticas que puedan llamarse.  jemplo: 

static function descuento_gobierno(){

self:$ayuda = 4500;
}

y s elo llama desd ela clase d eigual modo: 

Compra_veiculo::descuento_gobierno ();


 
**************** arrays: ' => ', foreach, for,  count(), sort(), var_dump().


en el array asociativo ( el nommal e sigual a todos los ya vistos) tiene el uso de este signo '=>' que no e sel mismo operador flecha que ya se usó '->' que es para hacer referencia a metodos y propiedades de un objeto. Esta flacha nueva '=>' se usa para asociar un dato a un nombre dentro de un array. 

$datos=array("Nombre"=>"Juan", "Apellido => "Goméz", Edad"=> 21)

para imprimir, hacer referencia a alguna de estas posiciones, se pordría escribir 

echo $datos["Apellido"]; 

>>>> Goméz


para agregar un dato a un array asociativo : 

$datos["pais"]= España";



existe la funcion is_array($datos) que puede ponerse en un if() para poder comprobar si se trata d eun array o no. 

para recorrer un array con un foreach se hace : 

foreach( "nombre del array", as, "nombre de de la clave", =>, "nombre del valor" ) 
Ej: 

      foreach($datos as $clave=> $valor) {

		echo "A $clave le corresponde $$valor"

        }



$semana[] = "Lunes";
$semana[] = "Martes";
$semana[] = "Miercoles";

tambien s epuede : 

$semana = array("Lunes","Martes","Miercoles");



un for clasico se veria igual, solo que hay que recordar el uno del $ 


for ($i=0;$i<4;$i++){

	echo $semana[$i]. <br>;
}

tambien en vez de 4, podria usarse count($semana)

la funcion sort() ordena alfabeticamente 

   sort($semana); 


array asociativo de dos dimenciones: 


$alimentos =array("fruta"=>array ("tropical" = "kiwi",
				   "citrico"=>"mandarina",
				   "otros" =>"manzana"),
		   "Leche"=> array ("animal=>"vaca",
				    "vegetal=>"coco"),
                    "carne"=>array ("vacuno=>""lomo",
				    "porcino"=>"pata"));	



foreache ($alimentos as $clave_alim=>$alim){


   echo $clave_alim:<br>;
  
    
   while (list ($clave,$valor)=each($alim)) {

              echo "$clave=$valor<br>"

          }

            echo "<br>"; 
}

				
basicamente un while dentro del for que va recorriendo cada array dentro del array. Esto se podría hacer con un var_dump($alimentos) y listo, sin todo el codigo anterior.  



******************************** coneccion a BBDD

se requieren 4 datos: 

Direccion de la BBDD.  (localhost) si es un server local, o el que nos de el proveedor de servicios web. 
Nombre de la BBDD       a legir. 
Usuario de la BBDD      a legir, que por defecto en local es ROOT
Contraseña de la BBDD   a elegir: que generalmente en local es ninguna. 


<?php 

	$db_host="localhost";
	$db_nombre="pruebas";
	$db_usuario="root";
	$db_contra="";

   /ahora van las variables en el connect en este orden: /

       $conexion=mysqli_connect($db_host,$db_usuario,$db_contra,$db_nombre);

   / se crea una consulta de prueba/

     $consulta="SELECT * FROM nombredelatabla";

     $resultados=mysqli_query($conexion, $consulta);

    $fila=mysqli_fetch_row($resultados);      / esta funcion ve fila por fila lo que ha en un array, en este caso en $resultado. 


     echo $fila[0]    //veamos que hay en la posicion cero de ese array
	
?>


se puede agregar una funcion que sedispare en caso de que haya habiado un herror de coneccion con la BBDD:  



	if(mysqli_connect_errno()) {

		echo "Fallo al conectar";
                exit();

	}


se puede agregar una linea que corrija caracteres comoa centos y demas. 

       mysqli_set_charset($conexion, "utf8"); 

//// un segundo modo de ver una mala coneccion con la base de datos consta de quitar el nombre de la base de datos de entre los argumentos deñ mysqli_connect, dejando solo los primeros tres. Y agregando un pedido de reconocimiento de esta luego de este modo: 


mysqli_select_db($conexion, $dbnombre) or die ("no se encuentra la base de datos")   

//agregando el 'or die', que va a dar un mensaje mas descrptivo. 



--- Se debe colocar la funcion 'mysqli_fetch_row' en un bucloe, ya que llama a solo una linea por vez. Lo ideal es un


		 While((fila=mysqli_fetch_row($resultados))==true){}



 mientras la variable que tiene el 'mysqli_fetch_row' tenga informacion, sea verdadera, se mantendrá en el while. 

puede utilizarse un array asociativo en la busqueda cambiando row por array, y agregando un segundo argumento: 


		 While((fila=mysqli_fetch_ARRAY($resultados, MYSQL_ASSOC))){   //EL TRUE SE ÚEDE DESCARTAR PORQUE YA ESTARÍA IMPLICITO

					echo $fila ['nombredeldatoAbuscar']

			}
el tipo d ebusqueda en este caso de como el de un array asociativo. Dentro del bucle. 



*********************************************************video 41! (ejercicio de consulta simple. 


https://www.youtube.com/watch?v=kb9aIrCiyE4&ab_channel=pildorasinformaticas


*************************************** paso de datos entre páginas. GET-POST

GET  : Envia los parametros de una página a otra a travez de la URL. Esta info queda en al caché de la maquina, por l que no e smuy recomendables. Por lo que lps navegadores las penalizan, ademas genera una url muy larga a veces. 

POST  : Al usar este se debe modificar lapagina que recibe  de $_GET[] a $POST[]. se queire con post que se tenga mas cuidado al enviar informacion y que no se vea. Al enviar mucha cantidad de texto resulta lo más cómodo. 






en la comunicacion entre dos o ma spáginas, los datos se pasan entre ellas teniendo en cuenta varios datos

- el action del <form> indica a que pagina irán dirigidos los datos del submit (boton) donde tambien debe aclararse el method: get/post. 

La instruccion '_GET["variable"]' toma el valor que s ehaya introducido en determinado cuadro de texto: 

   <input type="text" name= "buscar" value="botonito">  

   $variable = $_GET["buscar"];

Esto es valido mientras el method sea GET. 


****************************************** programacion con POO*************



hasta ahora esta es la forma procedimental. La programacion con POO es otra: 



a partir de video 51 del tutorial php. Lasintaxis de coneccion es la siguiente: 


     $conexion = new mysqli("localHost", "root", "","pruebas");    //declaracion de objeto. 


	if($conexion->connect_errno){

		echo "falló la conexión" . $conexion->connect_errno; 

        }

originalmente escribiriamos en la forma procedimental la coneccion: 

        mysqli_set_charset($conexion, "utf8");  esta funcion que pedia estos dos argumentos. 

en este casi s eusa el objeto coneccion con sus sporpiedadrs y métodos. Solo pedirá al objeto $conexion la funcion set_charset


		$conexion->set_charset("utf8");     //con el -> llamando a una funcion. El  argumento de codificacion continua ahi. 

se crea una variable donde alamcenar la instruccion sql . 


 		$sql = "SELECT * FROM PRODUCTOS"

PROCEDIMENTAMENTE AQUI SE CREABA UNA VARIABLE QUE EJECUTA LA CONSULTA USANDO DS ARGUENTOS: coneccion e intrucccion  // 

		//$resultados=mysqli_query($conexion, $srq);

La forma POO de esto mismo sería : 

		 $resultados=$conexion->query($sql);

se puede agregar de manera opcionl una forma que mate un posible error: (esto es forma POO)

		if($conexion->errno){

			die($conexion->error);

		}

luego ya si entrariamos a la forma del while que creaba una variable, en este caso $fila, y la igualaba a mysqli_fetch_array, agregando dos argumentos, la variable donde esta la consulta, en este caso $resultados, y la forma en que se quiere manejar el array, asociativo o de indice, con una funcion tipo "MYSQL_ASSOC".quedando: 

			//while ($fila=mysqli_fetch_array($resultados,MYSQL_ASSOC)    


  la funcion dentro de POO: sería en cambio: 


			while ($fila=$resultados->fetch_assoc()){  //podría ser fetch_array, pero en ls indices envez d ir un nombre iría un n°: "$fila[0]"



   		 /*campos de consulta: ej


			echo "<table><tr><td>";
             		echo $fila['CODIGOARTICULO'] . "</td><td> ";
			echo $fila['SECCION'] . "</td><td><tr></table>";
			echo "<br>";


   		*/

}


finalmente se cerraría la coneccion :

		originalmente se pedia en mysqli_close($conexion)

En POO es : 

		$conexion->close();    //desde luego aqui no se usa unargumento, ya que es funcion del propio objeto coneccion. 


**************************************PDO [PHP DATA OBJET] 


es una capa de abstraccion entre el codigo PHP y las bases de datos, siendo un lenguaje de programacion orientado a objetos.  Permite conexiones a varios tipos de bases de datos. Es una librería con decena de metodos que pueden verse en php.net. 

para realizar una conexion se haria una variable, como hasta ahora, instanciando un objeto de PDO. con sus tres argumentos: el host con el que se quiere conectar y el nombre de la base de datos( en el caso es Localhost) seguido de  el nombre dela base de datos en concreto, y el nombre del usuario, aqui es root,y tercero y ulrimo la contrasea, que aqui es nula. 
--al tratars e d eun lenguaje orientado a objetos, todos e sun objeto, los errores tambien, y por esto tienen sus spropios metodos y propiedades. Estos errores que s epudiern producir se controlan en un blocke try-catch. 

<?php


	try {

		$base= new PDO( 'mysql:host=localhost; dbname=pruebas', 'root', ''); 

		}catch (Exeption $e)
	
			die('Error: ' . $e->GetMEssage();)  - aqui se obtiene el menaje del error. 

	     }


?>

para consultas preparadas ( esta sque no permiten inyecciones) hay varios metodos en en PDO. : 

se genera un objeto: (como en el ejemplo de arriba):

$base= new PDO( 'mysql:host=localhost; dbname=pruebas', 'root', '');

de este objeto s epuede desprender llamados a funciones como  "prepre"

   $base->prepare($sql)   // donde esta variable SQL es una sentencia tipo SELECT, por caso. 


esto nos devuelve el objeto 'PDOStatement'. Que al ejecutarlo y asociarlo a un array ( en dos metodos diferentes, se ve el resultado. 



<?php

    $busqueda= $_GET["buscar"];

	try {

		$base= new PDO( 'mysql:host=localhost; dbname=pruebas', 'root', ''); 
		
		$base->setAtribute(PDO::ATTR_ERRMODE, PDP::ERRMODE_EXCEPTION); // cuando se crea el objeto exeption, si hay un error, se llama a propiedades y métodos de este.
		
		$base->exec("SET CHARACTER SET utf8");   ( para aceptar tipos de caracteres cona cento. 
		$sql= "SELECT NOMBREARTICULO FROM PRODUCTOS WHERE NOMBRE= ?"; //importante el '?'( esto forma parte de la centencia preparada)

		$resultado=$base->prepre ($sql);   //asi $resultado será un objeto de tipo 'PDOStatement'AHORA EJECURARLO Y RECORRER RESULTADOS: 

		$resultado->execute (array($busqueda));  //el argumento dentro delarray es lo que se va a tomar donde se encuentra el signo de pregunta. en este caso es un $_GET que esta tomando un dato obtenido desde otro formulario. 

		while ($registro = $resultado->fetch(PDO::FETCH_ASSOC)){  //$registro es uan variable instanciada qui mismo. 


                   echo "Nombre Articulo" .  $registro['NOMBREARTICULO']. "<br>"; 


		}


		$resultado->closeCursor();  //cerrar base de datos!!!


		}catch (Exeption $e)
	
			die('Error: ' . $e->GetMEssage();)  - aqui se obtiene el menaje del error. 

	     }


?>



El "?" al final de a consulta SQL puede ser sustituido por un marcador si lo que se desea es hacer una busqueda con un array de tipo asociativo. Donde buscas mas cosas a la vez. A continuaicon el ejemplo anterior, con marcadores, pero si las alcaraciones: 



<?php

    $busqueda= $_GET["buscar"];

	try {

		$base= new PDO( 'mysql:host=localhost; dbname=pruebas', 'root', ''); 
		
		$base->setAtribute(PDO::ATTR_ERRMODE, PDP::ERRMODE_EXCEPTION);  
		
		$base->exec("SET CHARACTER SET utf8");   
		$sql= "SELECT NOMBREARTICULO FROM PRODUCTOS WHERE NOMBRE= :n_art"; (AQUI SE PONE UN MARCADOR COMO ESTE)

		$resultado=$base->prepre ($sql);   /

		$resultado->execute (array(":n_art"=>$busqueda));  y aqui se coloca el marcador con el simbolo "=>" apuntando a la variable que viene desde el formulario...y fin. 

		while ($registro = $resultado->fetch(PDO::FETCH_ASSOC)){  


                   echo "Nombre Articulo" .  $registro['NOMBREARTICULO']. "<br>"; 


		}


		$resultado->closeCursor();  


		}catch (Exeption $e)
	
			die('Error: ' . $e->GetMEssage();) 

	     }


?>

--En caso de querer dar mas de un dato para la busqueda en este ultimo formato de busqueda: deberiamos hacer un formulario que pase dos datos al $_GET de la página php. se tomarian esos dos valores en dos variables. Y en la consulta SQL : -(el resto es igual a lo anterior)-

$busqueda_val1=$_GET["name del type=text"];
$busqueda_val2=$_GET["name del type=text"];

$sql= "SELECT NOMBREARTICULO FROM PRODUCTOS WHERE ValordealgunaColumna1 = :val1 AND ValordeLaSegundacolumna =: Val2";

//////////Luego se agregan estos en el execute: 

         $resultado->execute (array(":val1"=>$busqueda_val1, ":Val2"=>$busqueda_val2 ));


******************************  una coneccion con tipo modulado en estilo POO: *******************************************

//notese que: declara la variable como protected arriba, y recien abajo la usa para instanciar un tipo deo bjeto "mysqli". El "require esta llamando a una funcion diferente que tiene todos los datos de coneccion que lleva 5 constantes, asi que s eusa la fincion define() con susu dos argumentos básicos, y sin usar el '$' : "
 -Archivo "config.pHp":

<?php
   

  	define ('DB_HOST, 'localhost');
 	define ('DB_USUARIO, 'root');
	define ('DB_CONTRA, '');
	define ('DB_NOMBRE, 'pruebas');
	define ('DB_CHARSET, 'utf8');

?>


<?php 

		 require ("config.php");

		class Conexion {

			protected $conexion_db;
			   
				public function Conexion (){

				$this->conexion_db=new mysqli(DB_HOST, DB_USUARIO, DB_CONTRA,DB_NOMBRE );

				if($this->conexion_db->connect_errno){

					echo "falló al conectar MYSql" . $this->conexion_db->connect_errno; (esto no da el tipo de error)

					return; 

                               }

				$this->conexionconexion_db->set_charset(BD_CHARSET);  //para soportar acentos y eso

			}

		}


?>


se puede hacer uego uan clase que pida los productos, haciendo que esta herede de la clase Conexion.php: 
// notese que lo llama con el require, y luego lo hace parte d ela clase con un extends. 


<?php 

       require "Conexion.php"

   			 class DevuelveProductos Extends Conexion {

             public function DevuelveProductos() {

			parent::_contruct();  //con esta line ejecuta el contructor de la clase de la que se está heredando. 



            }

			public function get_productos(){ //entre los parentesis podría ir una variable que pudiera ser parte de la busqueda sql. 

				$resultado=$this->conexion_db->query('SELECT * FROM PRODUCTOS'); /la variable conexion_db se puede usar acá gracias a la herencia. 

en caso de pasarle una variable  por argumentos a esta funcion, la busqueda debería ser: xej: 'SELECT * FROM PRODUCTOS WHERE PAISDEORIGEN= "' .$parametro .' " ');

			       $productos=$resultado->fetch_all(MYSQLI_ASSOC);

				return $productos; //devulve lo que haya amacenado en productos

		}
			
}



( en esta última funcion entonces: conectamos con la basede datos (en la linea PARENT::), y una consulta sql (en $resultado)yque almacenamos en un array asociativo ($productos), y por último que nos lo devuelva. Faltaria el html que nos muestra ese resultado. )

para lo cual, y por modulacion, se agrega una nueva página de php: (que tambien tendrá el html)

<?php

		require "DevuelveProductos.php"

		$productos=new DevuelveProductos();   //con esto se llama al constructor de devuelve productos con la instanciacion. 

		$array_productos=$productos->get_productos();  //este metodo tenia una intruccion return que devuelve una rray que se almacene en esta avriable. 



?>
///en el mismo arhivo de este ultimo se trabajaria el html en conjunto: 

html5
        <body>

<?php 
		foreach ($array_productos as $elemento){
			echo "<table><tr><td>";
	             	echo $fila['CODIGOARTICULO'] . "</td><td> ";
			echo $fila['SECCION'] . "</td><td><tr></table>";
			echo "<br>";

		}
?php>
       </body>

		
	al tener el proyecto en varios archivos , se vuelve mas comodo reusar. ejemplo es que si modificas el archivo config ya se podría conectar con otra base de datos. O consultar otra tabla se trabaja con DevuelveProductos.php y semodifica la busqueda SQL. 



------------------------------------- funciones anonimas. (o expresiones lambda)


se llamana  a travez de una variable, ya que no tienen nombre: 

--se dan en una variable, a  al auw se le agrega el (),y la variable llamada debe terminar en ";"

$suma = function($a,$b){

    return $a + $b;
};

eho $suma(a:10, b:40);  //elagregado de un "a:" o "b:" no son necesarios,son agregados por el IDE 


>>>>50. 

--->se utilizan paragenerar filtros de busqueda en funciones como array_filter. 

$numeros= [1,2,0,3,4,5,6,7,8,9];

$mult_cinco = array_filter($numeros, function($n){
return $n % 5 == 0; 
});

print_r($mult_cinco);

----o en un array_map: 


$my_array= [1,2,0, null,3,'',4,[], 5,6,7,8,9];
$filtered = array_filter($my_array);

$result = array_map (function($value){

print_r($value);

}, $filtered);  

en ste ejemplo por caso si preguntasemmos a php si 'suma ', e suna funcion, a partirdel llamado var_dump(is_callable('suma')); //Devolvería false pq no existe la función suma sino la variable $suma que es una función anónima.


$suma = function ($a,$b){
return $a + $b;
};



------------**


las variables globales,(acá por ejemplo $nombre), que se quieran usar dentro de una funcion anónima deben tener la palabra reservada use*, o la funcion anonima no podría usarla. 


$nombre = "Mundo";

$saludo = function() use ($nombre)
{

echo "Hola $nombre";

};

$saludo();

>>> "Hola Mundo". 

...ademas se pueden seguir pasando parametros en function(aqui). 

***Entre los ejemplos de funciones anonimas : esta el comportamiento y llamado entre ellas: 

<?php

 function multiplicacion($a,$b){
    return $a * $b;
 }
    
 function operacion($function,$a,$b){
    echo $function($a,$b);
 }
    
  operacion('multiplicacion',5,3);

?> 

>>15. 

function operacion está enviando una funcion por argumento, está imprimiendo esa misma funcion que envía. funciona el return de la funcion que llama en "opercion". 


para usar las variables dentro d euna funcion debe lamarsela agregando Global a la misma, o no será tomada: 


<?php 

$frase = "frase del día":

echo $frase      

function decirLaFrase(){

  //      global $frase;     ( sin esta linea de codigo  el echo de la funcion no imprime.)

echo "<h1>$frase</h1>"; 

}

>> solo va a imprimir el primer echo. el de dentro d ela funcion no conoce la variable. a menos que adeante se le agregue global

lo mismo si se instanciara una variable dentro de la funcion. tendria que traerse el valor de esa variable dentro d ela funcion con un return. 
---------------------***unbuffered_query()


mysql_unbuffered_query() envía la consulta SQL query a MySQL, sin recuperar ni almacenar automáticamente en búfer las filas de resultados, como mysql_query() lo hace. Esto ahorra una considerable cantidad de memoria con las consultas SQL que producen conjuntos de resultados grandes, y se puede empezar a trabajar con el conjunto de resultados inmediatamente después de que la primera fila haya sido recuperada, ya que no es necesario esperar hasta que la consulta SQL completa haya sido ejecutada. Para usar mysql_unbuffered_query() mientras están abiertas múltiples conexiones a la base de datos, se debe especificar el parámetro opcional link_identifier para identificar qué conexión se desea utilizar.
Esto ahorra algo de memoria con consultas SQL grandes y puede comenzar a trabajar en el conjunto de resultados inmediatamente después de que se haya recuperado la primera fila.

---------------------*** call_user_func

call_user_func — Llamar a una llamada de retorno dada por el primer parámetro


---------------------***namespaces: 

tarea: https://www.youtube.com/watch?v=J4iTMzBZIvc&ab_channel=codigofacilito


en caso de tener en dos carpetas dos archivos php que se llamen iguales, para poder llamarlos sin generan un conflicto (porque el compilador no sabría a cual nos referimos), se le spuede asignar a cada una un namespace: 

<?php
namespace (nombre de la carpeta donde estamos trabajando ej"carpeta1"); 
class MiClase {}

?>

<?php
namespace (nombre de la carpeta donde estamos trabajando ej"carpeta2"); 
class MiClase {}

?>

para referirirnos a una clase u otra calse, ya que se llaman igual, aclaramos en el codigo el namespace del que proviene: 

<?php

use carpeta1\MiClase;

require_once('carpeta1/MiClase');
require_once('carpeta2/MiClase');

$UnaClase = new MiClase;   //sabe que hacemos referencia a la clase MiClase de  la carpeta 1 gracias a la primera linea de codigo "use..."

?> 

y si llamaramos a las dos clases se agrega "as": 

<?php

use carpeta1\MiClase;
use carpeta1\MiClase as UnaClase2; // aclarando como se llama la instancia en que va a trabajar. 

require_once('carpeta1/MiClase');
require_once('carpeta2/MiClase');

$UnaClase = new MiClase;   
$UnaClase2 = new MiClase;
?> 

------------------------------*** spl_object_hash


This function returns a UNIQUE IDENTIFIER for the object. This id CAN BE USE as a hash key for storing objects, or for identifying an object, as long as the object is not destroyed. Once the object is destroyed, its hash may be reused for other objects.


------------------------------*** splFixedArray


la clase SplFixedArray proporciona la funcionalidad principal de un ARRAY. La principal diferencia entre SplFixedArray y un array normal de PHP es que la clase SplFixedArray es de longitud fija y sólo permite enteros dentro del rango de índices. La ventaja es que usa menos memoría que un array estándar.


-----------------------------*** clase SplObjectStorage

La clase SplObjectStorage proporciona una correspondencia de objetos de datos o, ignorando los datos, un conjunto de objetos. Este doble propósito puede ser útil en muchos casos relacionados con la necesidad de identificar objetos de FORMA UNICA.

se ven tambien sus funciones attach y contains. 
<?php



$s = new SplObjectStorage();

$o1 = new StdClass;
$o2 = new StdClass;
$o3 = new StdClass;

$s->attach($o1);
$s->attach($o2);

var_dump($s->contains($o1));
var_dump($s->contains($o2));
var_dump($s->contains($o3));

$s->detach($o2);

var_dump($s->contains($o1));
var_dump($s->contains($o2));
var_dump($s->contains($o3));
?>
El resultado del ejemplo sería:

bool(true)
bool(true)
bool(false)
bool(true)
bool(false)
bool(false)


------------------------------------------*** saber el tipo de extencion de un archivo : 


El programa de abajo muestra si podemos usar la función pathinfo() para obtener la extensión del archivo.

<?php 
$path = "E:\work\CM\myppt.ppt";
$extension = pathinfo($path, PATHINFO_EXTENSION);
echo("The extension is $extension.");  
?> 

>>>The extension is ppt. 

Hemos pasado el parámetro $option. La función ha devuelto una string que contiene la extensión del archivo.


------------------------------------------***Scripts  (parte uno)
El script es un documento que contiene instrucciones, escritas en códigos de programación. El script es un lenguaje de programación que ejecuta diversas funciones en el interior de un programa de computador.

Los scripts se encargan de cumplir las siguientes funciones:

Combinar componentes.
Interactuar con el sistema operativo o con el usuario.
Controlar un determinado programa o aplicación.
Configurar o instalar sistemas operacionales, especialmente en los juegos, se usa para controlar las acciones de los personajes.
Algunos lenguajes de programación, usada como script son: ActionScript, JavaScript, Lua, PHP, Python, ShellScript, Ruby, VBScript.

Entre los inconvenientes de las aplicaciones dinámicas que hacen uso extensivo de una base de datos, destaca el incremento del uso de la memoria y CPU del sistema.

Cuando pedimos al servidor web que nos muestre una página estática, una página HTML normal, este nos devuelve su contenido tal cual. En cambio, cuando le pedimos que nos muestre un script de PHP, el servidor llama al motor de PHP el cual se encarga de interpretar el código del script y devolver el resultado de la ejecución de la misma. Obviamente, este segundo proceso de interpretación del código, es mucho más laborioso y por lo tanto consume más recursos del sistema.
Ante este problema, existen varias soluciones como el PHP Accelerator o el Zend Optimizer, que mediante diferentes métodos son capaces de reducir el tiempo de ejecución de los scripts o de incrementar la capacidad del servidor para mostrar páginas dinámicas. La mayoría de servidores tiene instalado alguna de estas soluciones, pero esto no significa que nosotros no debamos implementar un método alternativo para reducir el tiempo de ejecución de nuestros programas, así como reducir el consumo de recursos del sistema. Y de esto precisamente trata este artículo, te vamos a mostrar una forma sumamente sencilla de cachear tus scripts de PHP.

https://programacion.net/articulo/cacheando_tus_scripts_para_maxima_optimizacion_200



------------------------------------------***PHP.ini (control de  limite de recursos -scripts-) (parte Dos)

(https://www.cyberciti.biz/faq/php-resources-limits/)

 php.ini — el archivo de configuración principal en PHP.

Cuando se ejecuta PHP, este busca el archivo php.ini en algunas ubicaciones específicas y lo carga. Este archivo te permite ajustar algunas configuraciones importantes que debes tener en cuenta. Muy a menudo necesitarás ajustar las configuraciones en el archivo php.ini. Este proporciona un par de configuraciones importantes.la ubicación varía enormemente según el entorno en el que estés ejecutando PHP.


Aquí es donde la función phpinfo() viene al rescate. Esta te dirá en dónde se localiza el archivo php.ini y también mostrará toda la información importante en cuanto a la configuración de PHP

<?php
phpinfo();
?>

¿Cómo controlo y pongo LIMITES A LOS SCRIPTS php, como el tiempo máximo de ejecución de cada script y el tamaño del archivo de carga?

PHP admite las siguientes directivas de límites de recursos en el archivo php.ini:

max_execution_time : TIEMPO MAXIMO DE EJECUCION de cada script, en segundos.

max_input_time : CANTIDAD MÁXIMA DE TIEMPO que CADA SECUENCIA de comandos puede dedicar a analizar los datos de la solicitud.

memory_limit:  CANTIDAD MAXIMA DE MEMORIA  que puede consumir un SCRIPT.


------------------------------------------*** hasAttribute() 


Indica si un atributo llamado name existe como miembro del elemento.
Devuelve true en caso de éxito o false en caso de error.

tiene una version similarque es hasAttributeNS() pero en este caso debemos indcarle cual es el NaemSpace donde debemos buscar, por lo que es obvio que el primero no depnde de ello para hacer su trabajo. Trabajaria en una: non-spaced attribute.


------------------------------------------*** ___METHOD__ / __FUNCTION__:



__METHOD__ returns the name of the current class and method you are in when calling that constant.

http://php.net/manual/en/language.constants.predefined.php

__FUNCTION__ will only return the function name.
 
------------------------------------------***  instanceof 

Use esta palabra clave para determinar si un objeto es una instancia de una clase, una subclase de una clase, o implementa una interfaz específica y realiza las operaciones correspondientes.


<?php
interface ExampleInterface
{
   public function interfaceMethod();
 }
 class ExampleClass implements ExampleInterface
{
   public function interfaceMethod()
   {
     return 'Hello World!';
   }
 }
$exampleInstance = new ExampleClass();
 if($exampleInstance instanceof ExampleInterface){
   echo 'Yes, it is';
 }else{
   echo 'No, it is not';
} 
?>
>>>>sí, es


--------------------------------------------------***Variables de Session - sección 

https://aprende-web.net/php/php11_2.php

Una SECCION es el recorrido que hace un usuario por un sitio web, desde que entra hasta que sale, es decir todas las páginas que recorre el usuario durante la visita.

Las variables que se definen en una página, por norma general expiran al cerrar esa página, por lo que si queremos pasarlas a otra página debemos pasarlas, según lo visto hasta ahora, por los métodos POST o GET, o también podemos utilizar cookies.

A veces lo que nos interesa es tener algunas variables que se conserven durante toda la sesión, es decir durante todo el recorrido del usuario por nuestra web. Es decir crear variables de sesión. Tal puede ser el caso de webs o partes de la web restringidas a ciertos usuarios, o el típico caso de un carrito de la compra al que se le van añadiendo objetos en las distintas páginas.




--------------------------------------------------***SAFE_MODE

http://www.arumeinformatica.es/blog/directivas-php-safe_mode/#:~:text=Con%20la%20directiva%20safe_mode%20activada,un%20servidor%20compartido%2C%20generalmente%20es

Dice la documentación oficial de PHP que la directiva safe_mode es un intento de resolver un problema de seguridad en servidores compartidos. Y aunque sí mejora la seguridad no resulta una práctica infalible, ya que lleva a muchos proveedores de Internet (ISP) y programadores a pensar que están a salvo de amenazas de seguridad. Esto no debe ser del todo cierto cuando la comunidad PHP la ha declarado obsoleta en la versión 5, y no estará presente en la versión 6.

¿Cómo aumenta safe_mode la seguridad?
Con la directiva safe_mode activada PHP comprueba que el usuario actual es el propietario (UID) de los ficheros y directorios a los que desea acceder cada script, esto es verdaderamente útil cuando trabajamos con servidores compartidos, puesto que si un script sube un archivo a un servidor compartido, generalmente es guardado con el usuario web por defecto ("apache", "httpd", ...), por lo que sin la comprobación de usuario cualquier aplicación del servidor compartido podría acceder a nuestro fichero.

--------------------------------------------------*** Variables Globales: 


Las variables súper globales son variables integradas que siempre están disponibles en todos los ámbitos.


---------***SERVER  

$_SERVER es una variable súper global de PHP que contiene información sobre encabezados, rutas y ubicaciones de secuencias de comandos.

<?php
echo $_SERVER['PHP_SELF'];
echo "<br>";
echo $_SERVER['SERVER_NAME'];
echo "<br>";
echo $_SERVER['HTTP_HOST'];
echo "<br>";
echo $_SERVER['HTTP_REFERER'];
echo "<br>";
echo $_SERVER['HTTP_USER_AGENT'];
echo "<br>";
echo $_SERVER['SCRIPT_NAME'];
?>


-----------**+ $_ENV 

Una variable tipo array asociativo de variables pasadas al script actual a través del método del entorno.

Estas variables son importadas en el espacio de nombres global de PHP desde el entorno bajo el que está siendo ejecutado el intérprete PHP. (¡?)


---------***$_FILES

Un array asociativo de elementos subidos al script en curso a través del método POST. 



$_GET   


Existen dos métodos con los que el navegador puede enviar información al servidor:

Método HTTP GET. Información se envía de forma visible
El método GET envía la información codificada del usuario en el header del HTTP request, directamente en la URL. La página web y la información codificada se separan por un interrogante ?:
No se pueden enviar datos binarios (archivos, imágenes...).
En PHP los datos se administran con el array asociativo $_GET.

Método HTTP POST. Información se envía de forma no visible

 y 
---------***$_POST    


Con el método HTTP POST también se codifica la información, pero ésta se envía a través del body del HTTP Request, por lo que no aparece en la URL.

El método POST no tiene límite de cantidad de información a enviar.
La información proporcionada no es visible, por lo que se puede enviar información sensible.
Se puede usar para enviar texto normal así como datos binarios (archivos, imágenes...).
PHP proporciona el array asociativo $_POST para acceder a la información enviada.



-------------------------------------------------*** como prevenir inyecciones : (basico) 


https://stackoverflow.com/questions/8263371/how-can-prepared-statements-protect-from-sql-injection-attacks

mientras que este código

$spoiled_data = "1; DROP TABLE users;"
$query        = "SELECT * FROM users where id=$spoiled_data";
producirá una secuencia maliciosa

SELECT * FROM users where id=1; DROP TABLE users;
Funciona porque estamos agregando los datos directamente al cuerpo del programa y se convierte en parte del programa, por lo que los datos pueden alterar el programa y, según los datos pasados, tendremos una salida regular o una tabla userseliminada.

Mientras que en el caso de sentencias preparadas no alteramos nuestro programa, permanece intacto
Ese es el punto.

Primero estamos enviando un programa al servidor.

$db->prepare("SELECT * FROM users where id=?");
donde los datos se sustituyen por alguna variable llamada parámetro o marcador de posición.



-------------------------------------***.array_map 


The array_map() function sends each value of an array to a USER-MADE FUNCTION , and returns an array with new values, given by the user-made function.

Tip: You can assign one array to the function, or as many as you like."array_map(myfunction, array1, array2, array3, ...)"

<?php

function myfunction($v)
{
  return($v*$v);
}

$a=array(1,2,3,4,5);

print_r(array_map("myfunction",$a));
?>


-------------------------------------***INCLUDE - Require - Include_once y Require_once **

26

Include

inserta en nuestro programa un código procedente de otro archivo, en caso de que dicho archivo no exista o tenga errores en su interior nuestro programa mostrará un warning pero seguirá funcionando.

Require

Funciona de manera similar a include, pero en este caso, si el archivo no existe o contiene errores, nuestro programa no funcionará y obtendremos un fatal error en el log

Include_once y Require_once

Funcionan exactamente de la misma forma que las anteriores salvo que impiden la carga de un mismo fichero varias veces.

Conclusión final:

Podemos pensar en utilizar include cuando el archivo a introducir no sea determinante respecto al funcionamiento de nuestro programa. Require cuando dicho archivo sea necesario para el correcto funcionamiento de nuestro programa.

Finalmente se debe utilizar las variantes con _once cuando nuestro programa tenga unas dimensiones considerables y pueda darse el caso de que la inclusión del fichero se produzca varias veces. Estas últimas variantes hay que usarlas solo en casos excepcionales ya que consumen más recursos que las anteriores.


--------------------------------------------------------------



