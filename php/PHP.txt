
------------------------PHP:

--------------------------Variables: 


De forma predeterminada, las variables siempre se asignan por valor. Esto significa que cuando se asigna una expresión a una variable, el valor completo de la expresión original se copia en la variable de destino.
Para asignar por referencia, simplemente se antepone un signo ampersand (&) al comienzo de la variable cuyo valor se está asignando (la variable fuente). Por ejemplo, el siguiente segmento de código produce la salida 'Mi nombre es Bob' dos veces:

<?php
  $foo = 'Bob';                // Asigna el valor 'Bob' a $foo
  $bar = &$foo;                // Referenciar $foo vía $bar.
  $bar = "Mi nombre es $bar";  // Modifica $bar...
  echo $bar;
  echo $foo;                   // $foo también se modifica.
?>


En PHP, las variables globales deben ser declaradas globales dentro de la función si van a ser utilizadas dentro de dicha función.


<?php
	$a = 1;
	$b = 2;

	function Suma()
	{
 	   global $a, $b;

  	  $b = $a + $b;
	}

	Suma();
	echo $b;
?>


>>>>3.


--------------var_dump(); 

proporciona información sobre el tamaño y tipo de datos de la variable y, en el caso de arrays y objetos, de los elementos que la componen. 


--------------------------print_r 


no da información sobre el tamaño de la variable ni sobre el tipo de datos.


---------------------------------------------

- concatenacion con ' . ' : "esto es un ejemplo" . $variable; 

-para imrimir por pantalla se usa "echo" o "print": echo "esto e sun ejemplo" . $variable; 
echo permite separar variables por comas. 

-include  (nombreDEfuncion.php); incluye una funcion dentro del código que esté en otra parte. 

-require funciona igual, solo q interrumpe el flujo de ejecucion si har error.

-el ambito local de las variables se comportadiferente a otros lenguajes por causa de la existencia de estos dos llamados. ejemplo : 

<?php 
$nombre="Juan";

funcion dameNombre() {

$nombre= "María";

}

dameNombre();

echo $nombre; 

?>

>>>> Juan. 


sisis, daría juan, aunque en otro lenguaje debería dar MAria. PHP se asegura si que variables externas que sobreescriban no lo hagan con variables locales en llamados de este tipo (require-include) Incluso no se puede acceder desde dentro de una funcion a lo que hay fuera, de locales a lo que hay fuera. se debe convertir la varible interna en global : 

funcion dameNombre() {

global $nombre(); 

}

ahora sabe que tiene que ir a una variable global que fue declaradafuera de la funcion. 

Las variables estáticas: se agrega static delante de la variable, para que, por ejemplo, al llamar a una funcion una variable que tuviera un contador, esta incremente en cada caso que se la llame. 

----------------------------

comprobar ue se ha pulsado un boton : isset($_POST["enviado"]) 

$usuario=$POST["nombre_usuario"]   (esto corresponde al envio en metodo post de un formulario dnd el cuadro de ingreso de texto ((<input type="text" ))tiene un name="nombre_usario". 

-----------------------------

las CONSTANTES van con $ con mayusculas, es de ambito global, con valores escalares, (divisibles) y se definene en la funcion define() si o si. 

defin("AUTOR", "Juan") el primer argumento es el nombre, el segundo el valor, y puede haber un tercero que es un bool, que es para saber si es o no sensible a las mayusculas. (por si no usaron mayuscolas en el valor de la constante tal como es el convenio hacerlo)

Un ejemplo de una constante predefinida que s epuede encontrar en la pagina: https://www.php.net/manual/es/language.constants.predefined.php sería : 

echo "la linea de esta intruccion es : " . _LINE_; 

al venir con el lenguaje de forma predefinida nonecesitamos usa el define (). 

------------------------------ action =  

<form name = "form1"  method="post" action="calculadora.php">  action marca a que archvo php esta direccionado el form. 


--------------------------------


en el envio de parametros por valor o referencia en php sucede que , por ejemplo: 


function incrementa(&$valor1) {

$valor1++;
return $valor1;

}


$numero=5;

echo incrementa ($numero) . "<br>"

echo &numero; 

antes de agregar el &, el resultado hubiera sido un 5 en la primer linea, y un 6 en la segunda, pero ahora  el argumento de la funcion lo recivia por referencia, y no por valor como antes, donde el numero quedaba encapsulado dentro d ela funcion, si conocer ningun valor fuera. El & genera un vinculo, una referencia, con lo que hay fuera de la funcion. , asi que ahora al incrementar dentro d ela funcion, tambien se incrementa numero, esta vez se imprimirá dos veces un 6, el primero se refiere a la funcion, y el segundo a lo que se ha incrementado dentro de la funcion. REFERENCIA es un VINCULO, que afecta a esa variable en todas sus apariciones.



----------------------------------Calsses : (var , $this, ->, function() como metodo, contrusctor y herencia. 

declaracion: 


************

class Coche {

var $rueda;
var $motor; 

    function Coche() {

	ESTE ES EL METODO CONSTRUCTOR DE LA CLASE. 
	(SE LLAMA IGUAL A LA CLASE)     


        $this-> rueda = 4; 
    }


    function girar () {
      echo "estoy girando";
   }

}

$renault = new Coche(); 


************* Var


se usa Var para las propiedades. es el equivalente a Public, y puede pornerse como no. 


************* $this->

Los metodos y las funciones son sinonimos siempre que la funcion este dentro de la clase. al objeto que se este creando en cad amomento, por ejemplo no s elo usa en el caso de uq esea una variable d etipo static, ya que esas siempre pertenecen a la clase padre. 

--- $this-> rueda = 4;  [se usa el '->' para referenciar a la variable de clase, y el '$this' para referenciar a la clase dnd se está trabajando.  ]

Si se busca hacer una llamada a un método en una de las instancias de la case :


$renault->girar();  para un método
echo $renault->rueda; para un atributo. 


************** function


se puede cambiar el valor de una variable  con una funcion, por ejemplo : 


function cambia_color ($color_nuevo) {

$this->color=$color_coche;

echo "el color de este coche es:" . $this->color; 
		
}


$renault->cambia_color("rojo"); 


*************** Herencia: 


sintaxis : 

class Camion *extends* Coche {

}


*************** Parent : 



la isntruccion Parent hace un llamado a una funcion de la clase padre, d ela cual hereda la clase actual, y la ejecuta, para luego ejecutar el resto de comandos que se hallen dentro de la funcion donde fue llamada en la clase hijo. 

function arranca () {

   parent::arrancar()

     //otras intrucciones//

}

en este caso primero llamo a la funcion arrancar() que está en la clase super, padre, y luego dio lugar a otras intrucciones dentro de la funcion arranca(). 


*************** private:
 

se puede agregar private a var $ruedas = 4;

y con eso se encapsula. 

para acceder se usan metodos Getter y setter. en este caso se llamaría al objeto que posee la porpiedad, y a su metodo geter:

	 echo " el auto 1 tiene " .$auto1 ->get_ruedas() . "ruedas <br>";


*************** protected:
 

los metodos getter y setter acceden a la variables d ela clase donde se hayan, por caso de sucederse uan herencia de esta clase, el objeto que herede los metodos no podrá acceder a sus propias variables utilizando lso getter y setter heredados. El modificador ***protected*** permite que las variables que se heredan puedan ser accedidas tambien desde otras clases herederas con métodos settet y getter heredados de igual modo. 


**************** static. -- self::

en el caso de PHP se usa el operado self para hacer referencia a una variable de tipo estatica, a diferencia de $this-> que solo hace referencia a aun campo de clase  de la clase donde se encuentra. el operador Self:: hace *referencia* a un campo estatico. dnd la -> se reempleza por el ::


si se desea restar diferentes variables de clase , o sumar, o lo que sea, se debe recordar si llevan &this, o self:: conforme si son de la propia clase o de la clase d ela que se está heredando y que alli sea static. :

 function precio_final () {

   $valor_final= $this->precio_base - self::$ayuda;

   return $valor final;


   }

En este ejemplo 1) '$valor final' esta declarado dentro del propio método, por eso no lleva '$this->',2)precio base si lleva '$this->' porque pertenece a la clase donde se está trabajando, y 3) $ayuda es una variable de clase heredada de tipo static, por lo que en vez de '$this->' lleva 'self::'.

Para llamar a un campo Static se debe usar la clase como en todo lenguaje. solo que en vez de un punto, se usan  los dos dos puntos ::   

compra_veiculo::$ayuda=1000 

en otros lenguajes se veria asi : 

compra_veiculo.ayuda; 

(importante:'$ayuda' no estaría en private en este caso, por eso no se esta usando un setter. )
una vez declaradas como private se debe acceder a ellas con un metodo, igualmente statatico. 

las variables estaticas se pueden trabajar desde funciones estaticas que puedan llamarse.  jemplo: 

static function descuento_gobierno(){

self:$ayuda = 4500;
}

y s elo llama desd ela clase d eigual modo: 

Compra_veiculo::descuento_gobierno ();


 
**************** arrays: ' => ', foreach, for,  count(), sort(), var_dump().


en el array asociativo ( el nommal e sigual a todos los ya vistos) tiene el uso de este signo '=>' que no e sel mismo operador flecha que ya se usó '->' que es para hacer referencia a metodos y propiedades de un objeto. Esta flacha nueva '=>' se usa para asociar un dato a un nombre dentro de un array. 

$datos=array("Nombre"=>"Juan", "Apellido => "Goméz", Edad"=> 21)

para imprimir, hacer referencia a alguna de estas posiciones, se pordría escribir 

echo $datos["Apellido"]; 

>>>> Goméz


para agregar un dato a un array asociativo : 

$datos["pais"]= España";



existe la funcion is_array($datos) que puede ponerse en un if() para poder comprobar si se trata d eun array o no. 

para recorrer un array con un foreach se hace : 

foreach( "nombre del array", as, "nombre de de la clave", =>, "nombre del valor" ) 
Ej: 

      foreach($datos as $clave=> $valor) {

		echo "A $clave le corresponde $$valor"

        }



$semana[] = "Lunes";
$semana[] = "Martes";
$semana[] = "Miercoles";

tambien s epuede : 

$semana = array("Lunes","Martes","Miercoles");



un for clasico se veria igual, solo que hay que recordar el uno del $ 


for ($i=0;$i<4;$i++){

	echo $semana[$i]. <br>;
}

tambien en vez de 4, podria usarse count($semana)

la funcion sort() ordena alfabeticamente 

   sort($semana); 


array asociativo de dos dimenciones: 


$alimentos =array("fruta"=>array ("tropical" = "kiwi",
				   "citrico"=>"mandarina",
				   "otros" =>"manzana"),
		   "Leche"=> array ("animal=>"vaca",
				    "vegetal=>"coco"),
                    "carne"=>array ("vacuno=>""lomo",
				    "porcino"=>"pata"));	



foreache ($alimentos as $clave_alim=>$alim){


   echo $clave_alim:<br>;
  
    
   while (list ($clave,$valor)=each($alim)) {

              echo "$clave=$valor<br>"

          }

            echo "<br>"; 
}

				
basicamente un while dentro del for que va recorriendo cada array dentro del array. Esto se podría hacer con un var_dump($alimentos) y listo, sin todo el codigo anterior.  



******************************** coneccion a BBDD

se requieren 4 datos: 

Direccion de la BBDD.  (localhost) si es un server local, o el que nos de el proveedor de servicios web. 
Nombre de la BBDD       a legir. 
Usuario de la BBDD      a legir, que por defecto en local es ROOT
Contraseña de la BBDD   a elegir: que generalmente en local es ninguna. 


<?php 

	$db_host="localhost";
	$db_nombre="pruebas";
	$db_usuario="root";
	$db_contra="";

   /ahora van las variables en el connect en este orden: /

       $conexion=mysqli_connect($db_host,$db_usuario,$db_contra,$db_nombre);

   / se crea una consulta de prueba/

     $consulta="SELECT * FROM nombredelatabla";

     $resultados=mysqli_query($conexion, $consulta);

    $fila=mysqli_fetch_row($resultados);      / esta funcion ve fila por fila lo que ha en un array, en este caso en $resultado. 


     echo $fila[0]    //veamos que hay en la posicion cero de ese array
	
?>


se puede agregar una funcion que sedispare en caso de que haya habiado un herror de coneccion con la BBDD:  



	if(mysqli_connect_errno()) {

		echo "Fallo al conectar";
                exit();

	}


se puede agregar una linea que corrija caracteres comoa centos y demas. 

       mysqli_set_charset($conexion, "utf8"); 

//// un segundo modo de ver una mala coneccion con la base de datos consta de quitar el nombre de la base de datos de entre los argumentos deñ mysqli_connect, dejando solo los primeros tres. Y agregando un pedido de reconocimiento de esta luego de este modo: 


mysqli_select_db($conexion, $dbnombre) or die ("no se encuentra la base de datos")   

//agregando el 'or die', que va a dar un mensaje mas descrptivo. 



--- Se debe colocar la funcion 'mysqli_fetch_row' en un bucloe, ya que llama a solo una linea por vez. Lo ideal es un


		 While((fila=mysqli_fetch_row($resultados))==true){}



 mientras la variable que tiene el 'mysqli_fetch_row' tenga informacion, sea verdadera, se mantendrá en el while. 

puede utilizarse un array asociativo en la busqueda cambiando row por array, y agregando un segundo argumento: 


		 While((fila=mysqli_fetch_ARRAY($resultados, MYSQL_ASSOC))){   //EL TRUE SE ÚEDE DESCARTAR PORQUE YA ESTARÍA IMPLICITO

					echo $fila ['nombredeldatoAbuscar']

			}
el tipo d ebusqueda en este caso de como el de un array asociativo. Dentro del bucle. 



*********************************************************video 41! (ejercicio de consulta simple. 


https://www.youtube.com/watch?v=kb9aIrCiyE4&ab_channel=pildorasinformaticas


*************************************** paso de datos entre páginas. GET-POST

GET  : Envia los parametros de una página a otra a travez de la URL. Esta info queda en al caché de la maquina, por l que no e smuy recomendables. Por lo que lps navegadores las penalizan, ademas genera una url muy larga a veces. 

POST  : Al usar este se debe modificar lapagina que recibe  de $_GET[] a $POST[]. se queire con post que se tenga mas cuidado al enviar informacion y que no se vea. Al enviar mucha cantidad de texto resulta lo más cómodo. 






en la comunicacion entre dos o ma spáginas, los datos se pasan entre ellas teniendo en cuenta varios datos

- el action del <form> indica a que pagina irán dirigidos los datos del submit (boton) donde tambien debe aclararse el method: get/post. 

La instruccion '_GET["variable"]' toma el valor que s ehaya introducido en determinado cuadro de texto: 

   <input type="text" name= "buscar" value="botonito">  

   $variable = $_GET["buscar"];

Esto es valido mientras el method sea GET. 


****************************************** programacion con POO*************



hasta ahora esta es la forma procedimental. La programacion con POO es otra: 



a partir de video 51 del tutorial php. Lasintaxis de coneccion es la siguiente: 


     $conexion = new mysqli("localHost", "root", "","pruebas");    //declaracion de objeto. 


	if($conexion->connect_errno){

		echo "falló la conexión" . $conexion->connect_errno; 

        }

originalmente escribiriamos en la forma procedimental la coneccion: 

        mysqli_set_charset($conexion, "utf8");  esta funcion que pedia estos dos argumentos. 

en este casi s eusa el objeto coneccion con sus sporpiedadrs y métodos. Solo pedirá al objeto $conexion la funcion set_charset


		$conexion->set_charset("utf8");     //con el -> llamando a una funcion. El  argumento de codificacion continua ahi. 

se crea una variable donde alamcenar la instruccion sql . 


 		$sql = "SELECT * FROM PRODUCTOS"

PROCEDIMENTAMENTE AQUI SE CREABA UNA VARIABLE QUE EJECUTA LA CONSULTA USANDO DS ARGUENTOS: coneccion e intrucccion  // 

		//$resultados=mysqli_query($conexion, $srq);

La forma POO de esto mismo sería : 

		 $resultados=$conexion->query($sql);

se puede agregar de manera opcionl una forma que mate un posible error: (esto es forma POO)

		if($conexion->errno){

			die($conexion->error);

		}

luego ya si entrariamos a la forma del while que creaba una variable, en este caso $fila, y la igualaba a mysqli_fetch_array, agregando dos argumentos, la variable donde esta la consulta, en este caso $resultados, y la forma en que se quiere manejar el array, asociativo o de indice, con una funcion tipo "MYSQL_ASSOC".quedando: 

			//while ($fila=mysqli_fetch_array($resultados,MYSQL_ASSOC)    


  la funcion dentro de POO: sería en cambio: 


			while ($fila=$resultados->fetch_assoc()){  //podría ser fetch_array, pero en ls indices envez d ir un nombre iría un n°: "$fila[0]"



   		 /*campos de consulta: ej


			echo "<table><tr><td>";
             		echo $fila['CODIGOARTICULO'] . "</td><td> ";
			echo $fila['SECCION'] . "</td><td><tr></table>";
			echo "<br>";


   		*/

}


finalmente se cerraría la coneccion :

		originalmente se pedia en mysqli_close($conexion)

En POO es : 

		$conexion->close();    //desde luego aqui no se usa unargumento, ya que es funcion del propio objeto coneccion. 


**************************************PDO [PHP DATA OBJET] 


es una capa de abstraccion entre el codigo PHP y las bases de datos, siendo un lenguaje de programacion orientado a objetos.  Permite conexiones a varios tipos de bases de datos. Es una librería con decena de metodos que pueden verse en php.net. 

para realizar una conexion se haria una variable, como hasta ahora, instanciando un objeto de PDO. con sus tres argumentos: el host con el que se quiere conectar y el nombre de la base de datos( en el caso es Localhost) seguido de  el nombre dela base de datos en concreto, y el nombre del usuario, aqui es root,y tercero y ulrimo la contrasea, que aqui es nula. 
--al tratars e d eun lenguaje orientado a objetos, todos e sun objeto, los errores tambien, y por esto tienen sus spropios metodos y propiedades. Estos errores que s epudiern producir se controlan en un blocke try-catch. 

<?php


	try {

		$base= new PDO( 'mysql:host=localhost; dbname=pruebas', 'root', ''); 

		}catch (Exeption $e)
	
			die('Error: ' . $e->GetMEssage();)  - aqui se obtiene el menaje del error. 

	     }


?>

para consultas preparadas ( esta sque no permiten inyecciones) hay varios metodos en en PDO. : 

se genera un objeto: (como en el ejemplo de arriba):

$base= new PDO( 'mysql:host=localhost; dbname=pruebas', 'root', '');

de este objeto s epuede desprender llamados a funciones como  "prepre"

   $base->prepare($sql)   // donde esta variable SQL es una sentencia tipo SELECT, por caso. 


esto nos devuelve el objeto 'PDOStatement'. Que al ejecutarlo y asociarlo a un array ( en dos metodos diferentes, se ve el resultado. 



<?php

    $busqueda= $_GET["buscar"];

	try {

		$base= new PDO( 'mysql:host=localhost; dbname=pruebas', 'root', ''); 
		
		$base->setAtribute(PDO::ATTR_ERRMODE, PDP::ERRMODE_EXCEPTION); // cuando se crea el objeto exeption, si hay un error, se llama a propiedades y métodos de este.
		
		$base->exec("SET CHARACTER SET utf8");   ( para aceptar tipos de caracteres cona cento. 
		$sql= "SELECT NOMBREARTICULO FROM PRODUCTOS WHERE NOMBRE= ?"; //importante el '?'( esto forma parte de la centencia preparada)

		$resultado=$base->prepre ($sql);   //asi $resultado será un objeto de tipo 'PDOStatement'AHORA EJECURARLO Y RECORRER RESULTADOS: 

		$resultado->execute (array($busqueda));  //el argumento dentro delarray es lo que se va a tomar donde se encuentra el signo de pregunta. en este caso es un $_GET que esta tomando un dato obtenido desde otro formulario. 

		while ($registro = $resultado->fetch(PDO::FETCH_ASSOC)){  //$registro es uan variable instanciada qui mismo. 


                   echo "Nombre Articulo" .  $registro['NOMBREARTICULO']. "<br>"; 


		}


		$resultado->closeCursor();  //cerrar base de datos!!!


		}catch (Exeption $e)
	
			die('Error: ' . $e->GetMEssage();)  - aqui se obtiene el menaje del error. 

	     }


?>



El "?" al final de a consulta SQL puede ser sustituido por un marcador si lo que se desea es hacer una busqueda con un array de tipo asociativo. Donde buscas mas cosas a la vez. A continuaicon el ejemplo anterior, con marcadores, pero si las alcaraciones: 



<?php

    $busqueda= $_GET["buscar"];

	try {

		$base= new PDO( 'mysql:host=localhost; dbname=pruebas', 'root', ''); 
		
		$base->setAtribute(PDO::ATTR_ERRMODE, PDP::ERRMODE_EXCEPTION);  
		
		$base->exec("SET CHARACTER SET utf8");   
		$sql= "SELECT NOMBREARTICULO FROM PRODUCTOS WHERE NOMBRE= :n_art"; (AQUI SE PONE UN MARCADOR COMO ESTE)

		$resultado=$base->prepre ($sql);   /

		$resultado->execute (array(":n_art"=>$busqueda));  y aqui se coloca el marcador con el simbolo "=>" apuntando a la variable que viene desde el formulario...y fin. 

		while ($registro = $resultado->fetch(PDO::FETCH_ASSOC)){  


                   echo "Nombre Articulo" .  $registro['NOMBREARTICULO']. "<br>"; 


		}


		$resultado->closeCursor();  


		}catch (Exeption $e)
	
			die('Error: ' . $e->GetMEssage();) 

	     }


?>

--En caso de querer dar mas de un dato para la busqueda en este ultimo formato de busqueda: deberiamos hacer un formulario que pase dos datos al $_GET de la página php. se tomarian esos dos valores en dos variables. Y en la consulta SQL : -(el resto es igual a lo anterior)-

$busqueda_val1=$_GET["name del type=text"];
$busqueda_val2=$_GET["name del type=text"];

$sql= "SELECT NOMBREARTICULO FROM PRODUCTOS WHERE ValordealgunaColumna1 = :val1 AND ValordeLaSegundacolumna =: Val2";

//////////Luego se agregan estos en el execute: 

         $resultado->execute (array(":val1"=>$busqueda_val1, ":Val2"=>$busqueda_val2 ));


******************************  una coneccion con tipo modulado en estilo POO: *******************************************

//notese que: declara la variable como protected arriba, y recien abajo la usa para instanciar un tipo deo bjeto "mysqli". El "require esta llamando a una funcion diferente que tiene todos los datos de coneccion que lleva 5 constantes, asi que s eusa la fincion define() con susu dos argumentos básicos, y sin usar el '$' : "
 -Archivo "config.pHp":

<?php
   

  	define ('DB_HOST, 'localhost');
 	define ('DB_USUARIO, 'root');
	define ('DB_CONTRA, '');
	define ('DB_NOMBRE, 'pruebas');
	define ('DB_CHARSET, 'utf8');

?>


<?php 

		 require ("config.php");

		class Conexion {

			protected $conexion_db;
			   
				public function Conexion (){

				$this->conexion_db=new mysqli(DB_HOST, DB_USUARIO, DB_CONTRA,DB_NOMBRE );

				if($this->conexion_db->connect_errno){

					echo "falló al conectar MYSql" . $this->conexion_db->connect_errno; (esto no da el tipo de error)

					return; 

                               }

				$this->conexionconexion_db->set_charset(BD_CHARSET);  //para soportar acentos y eso

			}

		}


?>


se puede hacer uego uan clase que pida los productos, haciendo que esta herede de la clase Conexion.php: 
// notese que lo llama con el require, y luego lo hace parte d ela clase con un extends. 


<?php 

       require "Conexion.php"

   			 class DevuelveProductos Extends Conexion {

             public function DevuelveProductos() {

			parent::_contruct();  //con esta line ejecuta el contructor de la clase de la que se está heredando. 



            }

			public function get_productos(){ //entre los parentesis podría ir una variable que pudiera ser parte de la busqueda sql. 

				$resultado=$this->conexion_db->query('SELECT * FROM PRODUCTOS'); /la variable conexion_db se puede usar acá gracias a la herencia. 

en caso de pasarle una variable  por argumentos a esta funcion, la busqueda debería ser: xej: 'SELECT * FROM PRODUCTOS WHERE PAISDEORIGEN= "' .$parametro .' " ');

			       $productos=$resultado->fetch_all(MYSQLI_ASSOC);

				return $productos; //devulve lo que haya amacenado en productos

		}
			
}



( en esta última funcion entonces: conectamos con la basede datos (en la linea PARENT::), y una consulta sql (en $resultado)yque almacenamos en un array asociativo ($productos), y por último que nos lo devuelva. Faltaria el html que nos muestra ese resultado. )

para lo cual, y por modulacion, se agrega una nueva página de php: (que tambien tendrá el html)

<?php

		require "DevuelveProductos.php"

		$productos=new DevuelveProductos();   //con esto se llama al constructor de devuelve productos con la instanciacion. 

		$array_productos=$productos->get_productos();  //este metodo tenia una intruccion return que devuelve una rray que se almacene en esta avriable. 



?>
///en el mismo arhivo de este ultimo se trabajaria el html en conjunto: 

html5
        <body>

<?php 
		foreach ($array_productos as $elemento){
			echo "<table><tr><td>";
	             	echo $fila['CODIGOARTICULO'] . "</td><td> ";
			echo $fila['SECCION'] . "</td><td><tr></table>";
			echo "<br>";

		}
?php>
       </body>

		
	al tener el proyecto en varios archivos , se vuelve mas comodo reusar. ejemplo es que si modificas el archivo config ya se podría conectar con otra base de datos. O consultar otra tabla se trabaja con DevuelveProductos.php y semodifica la busqueda SQL. 



------------------------------------- funciones anonimas. (o expresiones lambda)


se llamana  a travez de una variable, ya que no tienen nombre: 

--se dan en una variable, a  al auw se le agrega el (),y la variable llamada debe terminar en ";"

$suma = function($a,$b){

    return $a + $b;
};

eho $suma(a:10, b:40);  //elagregado de un "a:" o "b:" no son necesarios,son agregados por el IDE 


>>>>50. 

--->se utilizan paragenerar filtros de busqueda en funciones como array_filter. 

$numeros= [1,2,0,3,4,5,6,7,8,9];

$mult_cinco = array_filter($numeros, function($n){
return $n % 5 == 0; 
});

print_r($mult_cinco);

----o en un array_map: 


$my_array= [1,2,0, null,3,'',4,[], 5,6,7,8,9];
$filtered = array_filter($my_array);

$result = array_map (function($value){

print_r($value);

}, $filtered);  

en ste ejemplo por caso si preguntasemmos a php si 'suma ', e suna funcion, a partirdel llamado var_dump(is_callable('suma')); //Devolvería false pq no existe la función suma sino la variable $suma que es una función anónima.


$suma = function ($a,$b){
return $a + $b;
};



------------**


las variables globales,(acá por ejemplo $nombre), que se quieran usar dentro de una funcion anónima deben tener la palabra reservada use*, o la funcion anonima no podría usarla. 


$nombre = "Mundo";

$saludo = function() use ($nombre)
{

echo "Hola $nombre";

};

$saludo();

>>> "Hola Mundo". 

...ademas se puedens eguir pasando parametros en function(aqui). 

***Entre los ejemplos de funciones anonimas : esta el comportamiento y llamado entre ellas: 

<?php

 function multiplicacion($a,$b){
    return $a * $b;
 }
    
 function operacion($function,$a,$b){
    echo $function($a,$b);
 }
    
  operacion('multiplicacion',5,3);

?> 

>>15. 

function operacion está enviando una funcion por argumento, está imprimiendo esa misma funcion que envía. funciona el return de la funcion que llama en "opercion". 






---------------------***unbuffered_query()


mysql_unbuffered_query() envía la consulta SQL query a MySQL, sin recuperar ni almacenar automáticamente en búfer las filas de resultados, como mysql_query() lo hace. Esto ahorra una considerable cantidad de memoria con las consultas SQL que producen conjuntos de resultados grandes, y se puede empezar a trabajar con el conjunto de resultados inmediatamente después de que la primera fila haya sido recuperada, ya que no es necesario esperar hasta que la consulta SQL completa haya sido ejecutada. Para usar mysql_unbuffered_query() mientras están abiertas múltiples conexiones a la base de datos, se debe especificar el parámetro opcional link_identifier para identificar qué conexión se desea utilizar.
Esto ahorra algo de memoria con consultas SQL grandes y puede comenzar a trabajar en el conjunto de resultados inmediatamente después de que se haya recuperado la primera fila.

---------------------*** call_user_func

call_user_func — Llamar a una llamada de retorno dada por el primer parámetro


---------------------***





